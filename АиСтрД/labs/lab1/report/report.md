## Цель Работы

Сравнительные испытания способов хранения множеств в памяти ЭВМ.

## Задание

Даны 4 произвольных по длине множества A, B, C, D с 16-ичным универсумом.
Найти все элементы, которые содержатся в A или C, но отсутствуют в B или D.

## Формализованное задание

### Представление множетва в виде массива битов

Воспользуемся способом представления множества отображением на универсум.

Пусть $A$, $B$, $C$, $D$ -- исходные множества. Определим множество $U$ -- универсум --
содержащее все элементы, встречающиеся в $A$, $B$, $C$ или $D$.

Тогда можно ввести множество $A'$:

$$ A' = \{ \forall u_i \in U | 1 \text{ if } u_i \in A \text{ else } 0 \} $$ {#eq:1}

Аналогично будут выглядеть и множества $B'$, $C'$, $D'$.

Таким образом, i-ый элемент множества $A'$, $B'$, $C'$ или $D'$ показывает, содержит ли
данное множество i-ый элемент универсума. Очевидно, мощность этих множеств
равна мощности универсума.

Отсюда вытекает формула для определения i-ого элемента множества $R'$:

$$ R'[i] = (A'[i] \lor C'[i]) \land \neg(B'[i] \lor D'[i]) $$ {#eq:2}

Теперь нужно провести операцию, обратную операции ({@eq:1}), и найти результирующее
множество R:

$$ R = { \forall u_i \in U: R'[i] = 1 } $$

### Представление множества в виде машинного слова

Используем универсум аналогично предыдущему представлению, только отображение 
множеств на этот универсум храним в машинном слове (unsigned int). Отображение 
выполняется с помощью битовых операций и маски.

### Представление множества в виде связного списка элементов

Каждый элемент множества представляет собой элемент односвязного списка. Не 
используется универсум. Для нахождения результирующего множества ({@eq:2}) 
реализованы функции-аналоги логических операций множества для списков.

### Представление множества в виде массива элементов

## Контрольные тесты

In: ["ABC123", "A3", "DA", "BCD"]
Out: ["12"]

In: ["0", "34", "f3", "4fa"]
Out: [""]

In: ["ABCDABCDABCDABCDABCD", "ABC", "2930", "3A"]
Out: ["209D"]

## Временная сложность

На основе исходного кода легко видеть, что будет выполнен один проход по
каждому введенному множеству. Стоит заметить, что также в коде фигурируют и
другие циклы, но они выполняются константное количество раз.

Тогда если принять мощность входных множеств соответственно за $n_1$, $n_2$, $n_3$,
$n_4$, то можно сделать вывод, что временная сложность $O$ будет:

$$ O(n_1, n_2, n_3, n_4) = n_1+n_2+n_3+n_4 \sim \max\{n_1, n_2, n_3, n_4\} $$

## Вывод

Структура представления множества, используемая в данной работе, позволяет
сильно упростить операции над множествами, сводя их к простым логическим
операциям. Но в то же время, этот способ имеет и ряд ограничений:

1.  Он применим только в случае конечного универсума (причем мощность
    должна быть небольшой).

2.  Должна существовать простая функция отображения множества на универсум.

3.  Он не учитывает дубликаты в множествах.

## Список источников

1. Лекция
2. Методичка

